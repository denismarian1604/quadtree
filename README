In cadrul acestei teme, m-am folosit de structurile TPixel ca tip de date pentru matricea de pixeli si TArb pentru structura unui nod din arbore, care contine pe langa informatia utila(culorile) si fiii nodului si procentul de similaritate, respectiv latura blocului asociat nodului.

In cadrul fisierului main, in functie de apelul din linia de comanda imi determin pozitia fisierelor in comanda si le deschid(urmand sa le inchid corespunzator in subprogramul fiecarei cerinte in parte).

Pentru cerintele 1 si 2 am facut un fisier sursa comun intrucat citirea se face din acelasi tip de fisier, diferentele aparand la informatiile ce trebuie afisate. In primul rand am citit informatiile despre matricea de pixeli(dimensiunile si valoare maxima) si ulterior matricea efectiv. Mai apoi am apelat functia constr_arb care are ca scop sa returneze arborele construit pe baza matricei de pixeli citita din fisier prin apelul subprogramului rezolva. Subprogramul rezolva nu face altceva decat sa verifice daca blocul curent mai trebuie sau nu divizat cu ajutorul subprogramului verif_val(care returneaza 1/0 daca blocul mai trebuie/nu mai trebuie divizat, conform cerintei). In cazul in care mai trebuie divizat se aloca nodul curent si se fac apelurile corespunzatoare pentru fiii acestuia. In caz contrar, apelul recursiv s-a incheiat; se copiaza informatiile in celul de nod si se returneaza nodul astfel creat. Pentru cerinta1, am functiile nr_niv(care imi calculeaza numarul de niveluri), nr_blocuri_sim(care imi calculeaza numarul de blocuri cu procentul de similaritate <= factorul furnizat) respectiv l_max_bloc(care imi calculeaza blocul cu latura maxima). Pentru cerinta 2, am functia de print care imi realizeaza afisarea pe nivel a arborelui(se determina numarul de niveluri, iar apoi pentru fiecare nivel se cauta nodurile de pe acel nivel si se afiseaza dupa care se trece la urmatorul nivel).

Pentru cerinta 3 citesc din fisier latura imaginii, iar apoi afisarea pe nivel a arborelui in vectorul v_grid care este de tipul TArb tocmai pentru ca este un vector de noduri. Ideea de rezolvare a acestui subpunct consta in realizarea legaturilor intre nodurile din vector, iar apoi doar sa facem arborele sa pointeze la primul nod din vector si astfel sa avem acces la arbore. Prima data parcurg fisierul pentru a vedea cate noduri sunt si pentru a imi da seama cu ce dimensiune trebuie alocat vectorul de noduri; ulterior resetez cursorul la inceput. Dupa citirea din fisier a nodurilor, apelam functia c3_constr_arb care are ca scop construirea arborelui pe baza vectorului de noduri. In cadrul acestui subprogram : se face ca radacina sa pointeze la primul element din vector(si anume primul element din fisier care va fi mereu radacina arborelui); daca avem mai mult de 1 element(radacina) apelam functia c3_rezolva. In functia acum apelata parcurgem vectorul de noduri, iar pentru fiecare nod de tip NOD(anume care nu este frunza, deci are copii) cautam copiii acestuia mai departe in vector(copiii vor fi primele poziti disponibile din vector), iar dupa ce ii gasim ii legam la parinte. Ulterior procesul se continua pana cand se fac toate legaturile. La final, obtinem in arborele a arborele cu legaturile corespunzatoare. Pentru reconstituirea matrcii de pixel se realizeaza procesul invers primelor 2 cerinte : se pleaca de la arbore si se injumatateste fiecare bloc pana cand ajungem la o frunza, iar atunci completam matricea cu culorile din acea frunza. Dupa completarea matricei, se va face afisarea acesteia in binar in fisierul de output impreuna cu informatiile specifice fisierului .ppm(P6, laturile si valoarea maxima a unui element).

Mentionez ca pentru realizarea implementarii arborelui cuaternar m-am documentat de pe leetcode(https://leetcode.com/problems/construct-quad-tree/).

Cerinta 1 : 20
Cerinta 2 : 30.0
Cerinta 3 : 30.0
Total     : 80.0
Bonus     : 20.0
Felicitari! Ai punctajul maxim: 80p! :)

